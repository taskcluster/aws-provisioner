{
  "name": "taskcluster-client",
  "version": "0.21.0",
  "author": {
    "name": "Jonas Finnemann Jensen",
    "email": "jopsen@gmail.com"
  },
  "description": "Client for interfacing taskcluster components",
  "license": "MPL-2.0",
  "scripts": {
    "test": "./test/runtests.sh"
  },
  "browser": "./browser.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/taskcluster/taskcluster-client.git"
  },
  "dependencies": {
    "lodash": "2.4.1",
    "debug": "2.1.0",
    "superagent": "0.21.0",
    "superagent-promise": "0.2.0",
    "superagent-hawk": "0.0.4",
    "amqplib": "0.2.1",
    "slugid": "1.0.3",
    "promise": "6.0.1",
    "hawk": "2.3.0",
    "url-join": "0.0.1",
    "sockjs-client-node": "0.1.1"
  },
  "optionalDependencies": {
    "sockjs-client-node": "0.1.1"
  },
  "devDependencies": {
    "mocha": "1.21.5",
    "taskcluster-base": "0.6.3",
    "commander": "2.4.0",
    "cliff": "0.1.9",
    "browserify": "6.1.0",
    "mocha-phantomjs": "3.5.1",
    "phantomjs": "^1.9.8"
  },
  "readme": "# TaskCluster Client [![Build Status](https://travis-ci.org/taskcluster/taskcluster-client.svg?branch=master)](https://travis-ci.org/taskcluster/taskcluster-client)\n_A taskcluster client library for node.js._\n\nThis client library is generated from the auto-generated API reference.\nYou can create a Client class from a JSON reference object at runtime using\n`taskcluster.createClient(reference)`. But there is also a set of builtin\nreferences from which Client classes are already constructed.\n\n## Calling API End-Points\nTo invoke an API end-point instantiate a taskcluster Client class, these are\nclasses can be created from a JSON reference object, but a number of them are\nalso built-in to this library. In the following example we instantiate an\ninstance of the `Queue` Client class and use to to create a task.\n\n```js\nvar taskcluster = require('taskcluster-client');\n\n// Instantiate the Queue Client class\nvar queue = new taskcluster.Queue({\n  credentials: {\n    clientId:     '...',\n    accessToken:  '...',\n    // Certificate must also be provided if using temporary credentials,\n    // this can be either a JSON object or a JSON string.\n    certificate:  {...}   // Only applicable for temporary credentials\n  }\n});\n\n// Create task using the queue client\nvar taskId = '...';\nqueue.createTask(taskId, task).then(function(result) {\n  // status is a task status structure\n  console.log(result.status);\n});\n```\n\nThe `payload` parameter is always a JSON object as documented by the REST API\ndocumentation. The methods always returns a _promise_ for the response JSON\nobject as documented in the REST API documentation.\n\n## Listening for Events\nMany TaskCluster components publishes messages about current events to pulse.\nThe JSON reference object also contains meta-data about declared pulse\nexchanges and their routing key construction. This is designed to make it easy\nto construct routing key patterns and parse routing keys from incoming messages.\n\nThe following example create a `listener` and instantiate an instance of\nthe Client class `QueueEvents` which we use to find the exchange and create\na routing pattern to listen for completion of a specific task. The\n`taskCompleted` method will construct a routing key pattern by using `*` or `#`\nfor missing entries, pending on whether or not they are single word or\nmulti-key entries.\n\n```js\nvar taskcluster = require('taskcluster-client');\n\n// Create a listener (this creates a queue on AMQP)\nvar listener = new taskcluster.PulseListener({\n  credentials: {\n    username:           '...',      // Pulse username from pulse guardian\n    password:           '...'       // Pulse password from pulse guardian\n  }\n});\n\n// Instantiate the QueueEvents Client class\nvar queueEvents = new taskcluster.QueueEvents();\n\n// Bind to task-completed events from queue that matches routing key pattern:\n//   'primary.<myTaskId>.*.*.*.*.*.#'\nlistener.bind(queueEvents.taskCompleted({taskId: '<myTaskId>'}));\n\n// Listen for messages\nlistener.on('message', function(message) {\n  message.exchange        // Exchange from which message came\n  message.payload         // Documented on docs.taskcluster.net\n  message.routingKey      // Message routing key in string format\n  message.routing.taskId  // Element from parsed routing key\n  message.routing.runId   // ...\n  message.redelivered     // True, if message has been nack'ed and requeued\n  message.routes          // List of CC'ed routes, without the `route.` prefix\n  return new Promise(...);\n});\n\n// Listen and consume events:\nlistener.resume().then(function() {\n  // Now listening\n});\n```\n\nTo bind to a custom routing-key like the task-specific routes that messages\nfrom the queue is CC'ed to, just provide the desired routing key to the\nmethod for exchange. See example below.\n\n```js\nvar RawRoutingPattern = 'route.task.specific.routing.key';\nlistener.bind(queueEvents.taskCompleted(RawRoutingPattern);\n```\n\n\n## Advanced Listening\n\nFor advanced queue usage the `connect` method can be used to\ncreate and bind the queue and return an associated\n[amqplib](http://www.squaremobius.net/amqp.node/doc/channel_api.html) channel:\n\n```js\nvar taskcluster = require('taskcluster-client');\n\n// Create a listener\nvar listener = new taskcluster.PulseListener({\n  username:     '...',\n  password:     '...'\n});\n\n// See: http://www.squaremobius.net/amqp.node/doc/channel_api.html\nvar channel = listener.connect().then(function(channel) {\n  return channel.consume(function(msg) {\n    channel.ack(msg);\n  });\n});\n```\n\nThe listener creates a AMQP queue, on the server side and subscribes to messages\non the queue. It's possible to use named queues, see details below. For details\non routing key entries refer to documentation on\n[docs.taskcluster.net](docs.taskcluster.net).\n\n**Remark,** API end-points and AMQP exchanges are typically documented in\nseparate reference files. For this reason they also have separate Client\nclasses, even if they are from the same component.\n\n## Documentation\nThe set of API entries listed below is generated from the built-in references.\nDetailed documentation with description, payload and result format details is\navailable on [docs.taskcluster.net](http://docs.taskcluster.net).\n\nOn the [documentation site](http://docs.taskcluster.net) entries often have a\n_signature_, you'll find that it matches the signatures below. Notice that all\nthe methods returns a promise. A method with `: void` also returns a promise,\nthat either resolves without giving a value or rejects with an error.\n\n<!-- START OF GENERATED DOCS -->\n\n### Methods in `taskcluster.Auth`\n```js\n// Create Auth client instance with default baseUrl:\n//  - https://auth.taskcluster.net/v1\nvar auth = new taskcluster.Auth(options);\n```\n * `auth.scopes(clientId) : result`\n * `auth.getCredentials(clientId) : result`\n * `auth.client(clientId) : result`\n * `auth.createClient(clientId, payload) : result`\n * `auth.modifyClient(clientId, payload) : result`\n * `auth.removeClient(clientId) : void`\n * `auth.resetCredentials(clientId) : result`\n * `auth.listClients() : result`\n * `auth.azureTableSAS(account, table) : result`\n * `auth.ping() : void`\n\n### Methods in `taskcluster.Scheduler`\n```js\n// Create Scheduler client instance with default baseUrl:\n//  - https://scheduler.taskcluster.net/v1\nvar scheduler = new taskcluster.Scheduler(options);\n```\n * `scheduler.createTaskGraph(taskGraphId, payload) : result`\n * `scheduler.extendTaskGraph(taskGraphId, payload) : result`\n * `scheduler.status(taskGraphId) : result`\n * `scheduler.info(taskGraphId) : result`\n * `scheduler.inspect(taskGraphId) : result`\n * `scheduler.inspectTask(taskGraphId, taskId) : result`\n * `scheduler.ping() : void`\n\n### Methods in `taskcluster.Index`\n```js\n// Create Index client instance with default baseUrl:\n//  - https://index.taskcluster.net/v1\nvar index = new taskcluster.Index(options);\n```\n * `index.findTask(namespace) : result`\n * `index.listNamespaces(namespace, payload) : result`\n * `index.listTasks(namespace, payload) : result`\n * `index.insertTask(namespace, payload) : result`\n * `index.ping() : void`\n\n### Methods in `taskcluster.Queue`\n```js\n// Create Queue client instance with default baseUrl:\n//  - https://queue.taskcluster.net/v1\nvar queue = new taskcluster.Queue(options);\n```\n * `queue.createTask(taskId, payload) : result`\n * `queue.getTask(taskId) : result`\n * `queue.defineTask(taskId, payload) : result`\n * `queue.scheduleTask(taskId) : result`\n * `queue.status(taskId) : result`\n * `queue.pollTaskUrls(provisionerId, workerType) : result`\n * `queue.claimTask(taskId, runId, payload) : result`\n * `queue.reclaimTask(taskId, runId) : result`\n * `queue.claimWork(provisionerId, workerType, payload) : result`\n * `queue.reportCompleted(taskId, runId, payload) : result`\n * `queue.reportFailed(taskId, runId) : result`\n * `queue.reportException(taskId, runId, payload) : result`\n * `queue.rerunTask(taskId) : result`\n * `queue.createArtifact(taskId, runId, name, payload) : result`\n * `queue.getArtifact(taskId, runId, name) : void`\n * `queue.getLatestArtifact(taskId, name) : void`\n * `queue.listArtifacts(taskId, runId) : result`\n * `queue.listLatestArtifacts(taskId) : result`\n * `queue.getPendingTasks(provisionerId) : void`\n * `queue.pendingTaskCount(provisionerId) : void`\n * `queue.pendingTasks(provisionerId, workerType) : void`\n * `queue.ping() : void`\n\n### Exchanges in `taskcluster.QueueEvents`\n```js\n// Create QueueEvents client instance with default exchangePrefix:\n//  - exchange/taskcluster-queue/v1/\nvar queueEvents = new taskcluster.QueueEvents(options);\n```\n * `queueEvents.taskDefined(routingKeyPattern) : binding-info`\n * `queueEvents.taskPending(routingKeyPattern) : binding-info`\n * `queueEvents.taskRunning(routingKeyPattern) : binding-info`\n * `queueEvents.artifactCreated(routingKeyPattern) : binding-info`\n * `queueEvents.taskCompleted(routingKeyPattern) : binding-info`\n * `queueEvents.taskFailed(routingKeyPattern) : binding-info`\n * `queueEvents.taskException(routingKeyPattern) : binding-info`\n\n### Exchanges in `taskcluster.SchedulerEvents`\n```js\n// Create SchedulerEvents client instance with default exchangePrefix:\n//  - exchange/taskcluster-scheduler/v1/\nvar schedulerEvents = new taskcluster.SchedulerEvents(options);\n```\n * `schedulerEvents.taskGraphRunning(routingKeyPattern) : binding-info`\n * `schedulerEvents.taskGraphExtended(routingKeyPattern) : binding-info`\n * `schedulerEvents.taskGraphBlocked(routingKeyPattern) : binding-info`\n * `schedulerEvents.taskGraphFinished(routingKeyPattern) : binding-info`\n\n<!-- END OF GENERATED DOCS -->\n\n## Construct Urls\nYou can build a url for any request, but this feature is mostly useful for\nrequest that doesn't require any authentication. If you need authentication\ntake a look at the section on building signed urls, which is possible for all\n`GET` requests. To construct a url for a request use the `buildUrl` method, as\nillustrated in the following example:\n\n```js\n// Create queue instance\nvar queue = new taskcluster.Queue(...);\n\n// Build url to get a specific task\nvar url = queue.buildUrl(\n  queue.getTask,    // Method to build url for.\n  taskId            // First parameter for the method, in this case taskId\n);\n```\n\nPlease, note that the `payload` parameter cannot be encoded in urls. And must be\nsent when using a constructed urls. Again, this is not a problem as most methods\nthat takes a `payload` also requires authentication.\n\n\n## Construct Signed Urls\nIt's possible to build both signed urls for all `GET` requests. A signed url\ncontains a query-string parameter called `bewit`, this parameter holds\nexpiration time, signature and scope restrictions (if applied). The signature\ncovers the following parameters:\n\n  * Expiration time,\n  * Url and query-string, and\n  * scope restrictions (if applied)\n\nThese signed urls is very convenient if you want to grant somebody access to\nspecific resource without proxying the request or sharing your credentials.\nFor example it's fairly safe to provide someone with a signed url for a\nspecific artifact that is protected by a scope. See example below.\n\n```js\n// Create queue instance\nvar queue = new taskcluster.Queue(...);\n\n// Build signed url\nvar signedUrl = queue.buildSignedUrl(\n  queue.getArtifactFromRun,   // method to build signed url for.\n  taskId,                     // TaskId parameter\n  runId,                      // RunId parameter\n  artifactName,               // Artifact name parameter\n  {\n    expiration:     60 * 10   // Expiration time in seconds\n});\n```\n\nPlease, note that the `payload` parameter cannot be encoded in the signed url\nand must be sent as request payload. This should work fine, just remember that\nit's only possible to make signed urls for `GET` requests, which in most cases\ndon't take a payload.\n\nAlso please consider using a relatively limited expiration time, as it's not\npossible to retract a signed url without revoking your credentials.\nFor more technical details on signed urls, see _bewit_ urls in\n[hawk](https://github.com/hueniverse/hawk).\n\n## Generating Temporary Credentials\nIf you have non-temporary taskcluster credentials you can generate a set of\ntemporary credentials as follows. Notice that the credentials cannot last more\nthan 31 days, and you can only revoke them by revoking the credentials that was\nused to issue them (this takes up to one hour).\n\n```js\nvar credentials = taskcluster.createTemporaryCredentials({\n  // Validity of temporary credentials starts here\n  start:              new Date(),\n  // Expiration of temporary credentials\n  expiry:             new Date(new Date().getTime() + 5 * 60 * 1000),\n  // Scopes to grant the temporary credentials\n  scopes:             ['ScopeA', 'ScopeB', ...]\n  credentials: {      // Non-temporary taskcluster credentials\n    clientId:         '...'\n    accessToken:      '...'\n  }\n});\n```\n\nYou cannot use temporary credentials to issue new temporary credentials.\n\n## Create Client Class Dynamically\nYou can create a Client class from a reference JSON object as illustrated\nbelow:\n\n```js\nvar reference = {...}; // JSON from references.taskcluster.net/...\n\n// Create Client class\nvar MyClient = taskcluster.createClient(reference);\n\n// Instantiate an instance of MyClient\nvar myClient = new MyClient(options);\n\n// Make a request with a method on myClient\nmyClient.myMethod(arg1, arg2, payload).then(function(result) {\n  // ...\n});\n```\n\n## Configuration of API Invocations\nThere is a number of configuration options for Client which affects invocation\nof API end-points. These are useful if using a non-default server, for example\nwhen setting up a staging area or testing locally.\n\n### Configuring API BaseUrls\nIf you use the builtin API Client classes documented above you can configure\nthe `baseUrl` when creating an instance of the client. As illustrated below:\n\n```js\nvar auth = new taskcluster.Auth({\n  credentials:  {...},\n  baseUrl:      \"http://localhost:4040\" // Useful for development and testing\n});\n```\n\n### Configuring Credentials\nWhen creating an instance of a Client class the credentials can be provided\nin options. For example:\n```js\nvar auth = new taskcluster.Auth({\n  credentials: {\n    clientId:     '...',\n    accessToken:  '...'\n  }\n});\n```\n\nYou can also configure default options globally using\n`taskcluster.config(options)`, as follows:\n\n```js\n// Configure default options\ntaskcluster.config({\n  credentials: {\n    clientId:     '...',\n    accessToken:  '...'\n  }\n});\n\n// No credentials needed here\nvar auth = new taskcluster.Auth();\n```\n\nIf the `clientId` and `accessToken` are left empty we also check the\n`TASKCLUSTER_CLIENT_ID` and `TASKCLUSTER_ACCESS_TOKEN` environment variables\nto use as defaults (similar to how AWS, Azure, etc. handle authentication).\n\n### Restricting Authorized Scopes\nIf you wish to perform requests on behalf of a third-party that has small set of\nscopes than you do. You can specify which scopes your request should be allowed\nto use, in the key `authorizedScopes`. This is useful when the scheduler\nperforms a request on behalf of a task-graph, or when authentication takes\nplace in a trusted proxy. See example below:\n\n```js\n// Create a Queue Client class can only define tasks for a specific workerType\nvar queue = new taskcluster.Queue({\n  // Credentials that can define tasks for any provisioner and workerType.\n  credentials: {\n    clientId:       '...',\n    accessToken:    '...'\n  },\n  // Restricting this instance of the Queue client to only one scope\n  authorizedScopes: ['queue:post:define-task/my-provisioner/my-worker-type']\n});\n\n// This request will only be successful, if the task posted is aimed at\n// \"my-worker-type\" under \"my-provisioner\".\nqueue.defineTask(taskId taskDefinition).then(function(result) {\n  // ...\n});\n```\n\n\n## Configuration of Exchange Bindings\nWhen a taskcluster Client class is instantiated the option `exchangePrefix` may\nbe given. This will replace the default `exchangePrefix`. This can be useful if\ndeploying a staging area or similar. See example below:\n\n```js\n\n// Instantiate the QueueEvents Client class\nvar queueEvents = new taskcluster.QueueEvents({\n  exchangePrefix:     'staging-queue/v1/'\n});\n\n// This listener will now bind to: staging-queue/v1/task-completed\nlistener.bind(queueEvents.taskCompleted({taskId: '<myTaskId>'}));\n```\n\n## Using the Listener\nTaskCluster relies on pulse for exchange of messages. You'll need an pulse\ncredentials for using `taskcluster.PulseListener`.\nAn outline of how to create an instance and use is given below. Note, you\nmust call `resume()` before message starts arriving.\n\n```js\nvar listener = new taskcluster.PulseListener({\n  prefetch:             5,          // Number of tasks to process in parallel\n  credentials: {                    // If not instance of PulseConnection\n    username:           '...',      // Pulse username from pulse guardian\n    password:           '...'       // Pulse password from pulse guardian\n  },\n  connection:           connection, // If credentials isn't provided\n  // If no queue name is given, the queue is:\n  //    exclusive, autodeleted and non-durable\n  // If a queue name is given, the queue is:\n  //    durable, not auto-deleted and non-exclusive\n  queueName:          'my-queue',   // Queue name, undefined if none\n  maxLength:          0,            // Max allowed queue size\n});\n\nlistener.connect().then(...);       // Setup listener and bind queue\nlistener.resume().then(...);        // Start getting new messages\nlistener.pause().then(...);         // Pause retrieval of new messages\nlistener.deleteQueue();             // Delete named queue and disconnect\nlistener.close();                   // Disconnect from pulse\n```\n\n**Using `PulseConnection`**, instead of giving a `username` and `password` it\nis possible to give the `Listener` the key `connection` which must then be a\n`taskcluster.PulseConnection` object. Using a `PulseConnection` object it's\npossible to have multiple listeners using the same AMQP TCP connection, which\nis the recommended way of using AMQP. Notice, that the `PulseConnection` will\nnot be closed with the `Listener`s, so you must `close()` it manually.\n\n```js\nvar connection = new taskcluster.PulseConnection({\n  username:           '...',        // Pulse username from pulse guardian\n  password:           '...'         // Pulse password from pulse guardian\n});\n\n// Create listener\nvar listener = new taskcluster.PulseListener({\n  connection:         connection,   // AMQP connection object\n});\n\n\nconnection.close();                 // Disconnect from AMQP/pulse\n```\n\n## Relative Date-time Utilities\nA lot of taskcluster APIs requires ISO 8601 time stamps offset into the future\nas way of providing expiration, deadlines, etc. These can be easily created\nusing `new Date().toJSON()`, however, it can be rather error prone and tedious\nto offset `Date` objects into the future. Therefore this library comes with two\nutility functions for this purposes.\n\n```js\nvar dateObject = taskcluster.fromNow(\"2 days 3 hours 1 minute\");\nvar dateString = taskcluster.fromNowJSON(\"2 days 3 hours 1 minute\");\nassert(dateObject.toJSON() === dateString);\n// dateObject = now() + 2 days 2 hours and 1 minute\nassert(new Date().getTime() < dateObject.getTime());\n```\n\nBy default it will offset the date time into the future, if the offset strings\nare prefixed minus (`-`) the date object will be offset into the past. This is\nuseful in some corner cases.\n\n```js\nvar dateObject = taskcluster.fromNow(\"- 1 year 2 months 3 weeks 5 seconds\");\n// dateObject = now() - 1 year, 2 months, 3 weeks and 5 seconds\nassert(new Date().getTime() > dateObject.getTime());\n```\n\nThe offset string is ignorant of whitespace and case insensitive. It may also\noptionally be prefixed plus `+` (if not prefixed minus), any `+` prefix will be\nignored. However, entries in the offset string must be given in order from\nhigh to low, ie. `2 years 1 day`. Additionally, various shorthands may be\nemployed, as illustrated below.\n\n```\n  years,    year,   yr,   y\n  months,   month,  mo\n  weeks,    week,   wk,   w\n  days,     day,          d\n  hours,    hour,   hr,   h\n  minutes,  minute, min\n  seconds,  second, sec,  s\n```\n\nThe `fromNow` method may also be given a date to be relative to as a second\nargument. This is useful if offset the task expiration relative to the the task\ndeadline or doing something similar.\n\n```js\nvar dateObject1 = taskcluster.fromNow(\"2 days 3 hours\");\n// dateObject1  = now() + 2 days and 3 hours\nvar dateObject2 = taskcluster.fromNow(\"1 year\", dateObject1);\n// dateObject2  = now() + 1 year, 2 days and 3 hours\n```\n\n## Using `taskcluster-client` in a Browser\nRunning the script `utils/browserify.js` will generate `taskcluster-client.js`\nusing browserify. This does not contain any listener, but all the API logic\nand references is present. To get AMQP events in the browser use\n[events.taskcluster.net](https://github.com/taskcluster/taskcluster-events).\n\n## Updating Builtin APIs\nWhen releasing a new version of the `taskcluster-client` library, we should\nalways update the builtin references using `utils/update-apis.js` this\nmaintenance script can be used to list, show, add, remove and update builtin\nAPI definitions.\n\nWhen `apis.json` is updated, please run `utils/generate-docs.js` to update\nthe documentation in this file.\n\n##License\nThe taskcluster client library is released on [MPL 2.0](http://mozilla.org/MPL/2.0/).\n",
  "readmeFilename": "README.md",
  "gitHead": "282888c4e855c3bdb9f3e1b316caf4fb1f1c00e0",
  "bugs": {
    "url": "https://github.com/taskcluster/taskcluster-client/issues"
  },
  "homepage": "https://github.com/taskcluster/taskcluster-client",
  "_id": "taskcluster-client@0.21.0",
  "_shasum": "41306828d13da2ae9415f312afd1ffc0e987699f",
  "_from": "taskcluster-client@0.21.0"
}
